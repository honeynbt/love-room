<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>LoveRoom ðŸ’–</title>
  <script src="https://cdn.socket.io/4.0.1/socket.io.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
  <style>
    :root {
      --keyboard-offset: 0px;
    }
    body { background-color: #000; margin: 0; padding: 0; overflow: hidden; }
    #remoteVideo {
      width: 100%;
      height: calc(100vh - var(--keyboard-offset));
      object-fit: cover;
      position: absolute;
      top: 0;
      left: 0;
      z-index: 1;
      transition: height 0.18s ease;
    }
    #localVideo {
      width: 120px;
      height: 160px;
      object-fit: cover;
      border-radius: 8px;
      border: 2px solid white;
      position: absolute;
      bottom: 20px;
      right: 20px;
      z-index: 2;
    }
    #localVideo.mirrored { transform: scaleX(-1); }
    #controls {
      position: absolute;
      bottom: 80px;
      left: 0;
      right: 0;
      display: flex;
      justify-content: center;
      gap: 15px;
      z-index: 3;
    }
    .control-btn { /* unchanged */ width: 50px; height: 50px; border-radius: 50%; display: flex; align-items: center; justify-content: center; cursor: pointer; background-color: rgba(255, 255, 255, 0.2); backdrop-filter: blur(5px); color: white; font-size: 20px; transition: background-color 0.3s; }
    #chat-container {
      position: absolute;
      bottom: 240px;
      left: 20px;
      right: 20px;
      max-height: 200px;
      overflow-y: auto;
      z-index: 3;
      display: none;
      padding: 10px;
      background-color: transparent;
      border-radius: 10px;
    }
    #messages { display:flex; flex-direction:column; gap:8px; }
    .message-bubble { max-width:80%; padding:8px 12px; border-radius:18px; color:white; word-wrap:break-word; }
    .my-message { background-color: rgba(0,0,0,0.4); margin-left:auto; border-bottom-right-radius:4px; text-shadow:0 0 5px black; }
    .partner-message { background-color: rgba(0,0,0,0.25); margin-right:auto; border-bottom-left-radius:4px; text-shadow:0 0 5px black; }
    #chat-input-container { position: absolute; bottom: 20px; left: 20px; right: 20px; display: flex; gap: 10px; z-index: 3; display: none; }
    #chat-input { flex-grow: 1; padding: 12px 20px; border-radius: 25px; border: none; background-color: rgba(255,255,255,0.95); font-size: 16px; }
    #send-btn { width: 50px; height: 50px; border-radius: 50%; background-color: #25D366; color: white; border: none; display: flex; align-items: center; justify-content: center; cursor: pointer; font-size: 20px; }
    #chat-toggle { position: absolute; bottom: 180px; right: 20px; width: 50px; height: 50px; border-radius: 50%; background-color: rgba(255,255,255,0.2); backdrop-filter: blur(5px); display:flex; align-items:center; justify-content:center; cursor:pointer; z-index:4; color:white; font-size:20px; transition:all 0.3s; }
    #chat-toggle.active { background-color: rgba(255,255,255,0.4); }
    #notification-badge { position:absolute; top:-5px; right:-5px; background-color:red; color:white; border-radius:50%; width:20px; height:20px; display:none; align-items:center; justify-content:center; font-size:12px; }
    #reactionOverlay { position:fixed; top:0; left:0; width:100%; height:100%; pointer-events:none; display:flex; align-items:center; justify-content:center; font-size:100px; z-index:5; animation:fadeOut 2s ease-in-out forwards; text-shadow:0 0 20px rgba(255,0,0,0.8); display:none; }
    @keyframes fadeOut { 0% { opacity:1; transform:scale(1); } 100% { opacity:0; transform:scale(2); } }
    #connectionStatus { position:absolute; top:20px; left:20px; padding:5px 10px; border-radius:20px; color:white; background-color:rgba(0,0,0,0.5); z-index:3; font-size:14px; }
    #typingIndicator { color:white; font-style:italic; font-size:12px; padding:5px 10px; display:none; background-color:rgba(0,0,0,0.3); border-radius:10px; margin-top:5px; width:fit-content; }
    #roomFullOverlay { position:fixed; top:0; left:0; width:100%; height:100%; background-color:rgba(0,0,0,0.8); display:flex; flex-direction:column; align-items:center; justify-content:center; z-index:10; color:white; font-size:24px; text-align:center; padding:20px; display:none; }
    #roomFullOverlay button { margin-top:20px; padding:10px 20px; background-color:#25D366; border:none; border-radius:5px; color:white; font-size:16px; cursor:pointer; }
  </style>
</head>
<body>
  <div id="connectionStatus">Connecting...</div>
  <div id="roomFullOverlay">
    <h2>This room is already full!</h2>
    <p>Only 2 people can join a LoveRoom at a time.</p>
    <button onclick="window.location.href='/'">Go Back</button>
  </div>

  <video id="remoteVideo" autoplay playsinline></video>
  <video id="localVideo" autoplay muted playsinline class="mirrored"></video>

  <div id="controls">
    <div id="micToggle" class="control-btn">ðŸŽ¤</div>
    <div id="camToggle" class="control-btn">ðŸ“·</div>
    <div id="flipCam" class="control-btn">ðŸ”„</div>
    <div id="endCall" class="control-btn bg-red-500">ðŸ“ž</div>
    <div id="heartBtn" class="control-btn">ðŸ’“</div>
    <div id="kissBtn" class="control-btn">ðŸ’‹</div>
  </div>

  <div id="chat-toggle">
    ðŸ’¬
    <div id="notification-badge"></div>
  </div>

  <div id="chat-container">
    <div id="messages"></div>
    <div id="typingIndicator">Partner is typing...</div>
  </div>

  <div id="chat-input-container">
    <input id="chat-input" type="text" placeholder="Type a message..." autocomplete="off" />
    <button id="send-btn">âž¤</button>
  </div>

  <div id="reactionOverlay"></div>

  <script>
  // ====== base variables ======
  const socket = io({ autoConnect: true, reconnectionAttempts: 3 });
  const MAX_RETRIES = 3;
  let retryCount = 0;
  let peerConnections = {};
  let localStream = null;
  const roomId = window.location.pathname.split('/').pop() || 'default';
  let currentFacing = "user";
  let micEnabled = true;
  let camEnabled = true;
  let chatOpen = false;
  let typingTimeout = null;
  let unreadMessages = 0;
  let password = ''; // will store room password
  // ====== helpers ======

  function updateConnectionStatus(status) {
    const statusEl = document.getElementById('connectionStatus');
    statusEl.textContent = status;
    statusEl.style.backgroundColor =
      status.includes('Connected') ? 'rgba(40,167,69,0.8)' :
      status.includes('Disconnected') ? 'rgba(220,53,69,0.8)' :
      'rgba(255,193,7,0.8)';
  }

  // scroll: prefer scrolling the last message into view (works when container hidden then opened)
  function scrollToBottom() {
    const msgs = document.getElementById('messages');
    if (!msgs) return;
    const last = msgs.lastElementChild;
    if (last) {
      try { last.scrollIntoView({ behavior: 'smooth', block: 'end' }); } catch (e) {
        const container = document.getElementById('chat-container');
        container.scrollTop = container.scrollHeight;
      }
    }
  }

  function sanitizeInput(input) {
    const div = document.createElement('div');
    div.textContent = input;
    return div.innerHTML;
  }

  function addMessage(sender, text, isMe) {
    const msg = document.createElement('div');
    msg.className = `message-bubble ${isMe ? 'my-message' : 'partner-message'}`;
    msg.innerHTML = `<strong>${sender}:</strong> ${sanitizeInput(text)}`;
    document.getElementById('messages').appendChild(msg);
    scrollToBottom();
  }

  function updateMessageBadge() {
    const badge = document.getElementById('notification-badge');
    if (unreadMessages > 0) {
      badge.style.display = 'flex';
      badge.textContent = unreadMessages > 9 ? '9+' : unreadMessages;
    } else {
      badge.style.display = 'none';
    }
  }

  // ====== encryption helpers (optional E2E for chat) ======
  // We'll encrypt chat using the room password (symmetric). If password is empty we skip encryption.
  function encryptForRoom(plaintext) {
    if (!password) return plaintext;
    try {
      return CryptoJS.AES.encrypt(plaintext, password).toString();
    } catch (e) {
      console.warn('Encrypt error', e);
      return plaintext;
    }
  }
  function decryptForRoom(ciphertext) {
    if (!password) return ciphertext;
    try {
      const bytes = CryptoJS.AES.decrypt(ciphertext, password);
      const str = bytes.toString(CryptoJS.enc.Utf8);
      return str || ciphertext; // fallback
    } catch (e) {
      console.warn('Decrypt error', e);
      return ciphertext;
    }
  }

  // ====== media init ======
  async function initMedia() {
    try {
      localStream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: currentFacing }, audio: true });
      document.getElementById('localVideo').srcObject = localStream;
      return true;
    } catch (err) {
      console.error('Media access error:', err);
      return false;
    }
  }

  // ====== create peer connection ======
  function createPeerConnection(userId) {
    const pc = new RTCPeerConnection({
      iceServers: [
        { urls: 'stun:stun.l.google.com:19302' },
        { urls: 'stun:stun1.l.google.com:19302' }
      ]
    });

    // Add local tracks (if available)
    if (localStream) {
      localStream.getTracks().forEach(track => {
        try { pc.addTrack(track, localStream); } catch (e) { console.warn('addTrack error', e); }
      });
    }

    pc.onicecandidate = ({ candidate }) => {
      if (candidate) {
        socket.emit('ice-candidate', { candidate, to: userId });
      }
    };

    pc.ontrack = (event) => {
      // set remote stream (first stream)
      document.getElementById('remoteVideo').srcObject = event.streams[0];
      updateConnectionStatus('Connected to partner');
    };

    pc.onconnectionstatechange = () => {
      console.log(`Connection state with ${userId}:`, pc.connectionState);
      if (pc.connectionState === 'connected') updateConnectionStatus('Connected');
      else if (pc.connectionState === 'disconnected') updateConnectionStatus('Disconnected');
    };

    pc.oniceconnectionstatechange = () => {
      if (pc.iceConnectionState === 'failed') {
        console.log('ICE failed, restarting ICE for', userId);
        try { pc.restartIce(); } catch (e) { console.warn('restartIce failed', e); }
      }
    };

    return pc;
  }

  // ====== signaling flows ======
  async function initiateCall(userId, pc) {
    try {
      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);
      socket.emit('sdp-offer', { offer, to: userId });
    } catch (err) {
      console.error('Offer error:', err);
    }
  }

  // ====== socket handlers ======
  socket.on('connect', () => {
    updateConnectionStatus('Connected to signaling server');
    console.log('socket connected', socket.id);
  });

  socket.on('disconnect', (reason) => {
    updateConnectionStatus('Disconnected from signaling server');
    console.log('socket disconnected', reason);
  });

  socket.on('reconnect_attempt', (attempt) => {
    updateConnectionStatus(`Reconnecting... (${attempt})`);
  });

  socket.on('existing-users', ({ users }) => {
    // users are the other participants already in the room
    users.forEach(userId => {
      if (!peerConnections[userId]) {
        const pc = createPeerConnection(userId);
        peerConnections[userId] = pc;
        // Initiate call to existing users (this client will be the offerer for them)
        initiateCall(userId, pc);
      }
    });
  });

  socket.on('user-connected', ({ userId }) => {
    // Someone else joined after us. Create PC and immediately offer to them.
    if (!peerConnections[userId]) {
      const pc = createPeerConnection(userId);
      peerConnections[userId] = pc;
      // Important: immediately initiate call so that the late joiner gets an offer
      initiateCall(userId, pc);
    }
  });

  socket.on('user-disconnected', ({ userId }) => {
    if (peerConnections[userId]) {
      try { peerConnections[userId].close(); } catch (e) {}
      delete peerConnections[userId];
      updateConnectionStatus('Partner disconnected');
    }
    // keep remote video cleared
    document.getElementById('remoteVideo').srcObject = null;
  });

  socket.on('room-full', () => {
    document.getElementById('roomFullOverlay').style.display = 'flex';
    // cleanup local resources
    if (localStream) localStream.getTracks().forEach(t=>t.stop());
    Object.values(peerConnections).forEach(pc => pc.close());
  });

  socket.on('invalid-password', () => {
    alert('Incorrect password!');
    window.location.href = '/';
  });

  // sdp-offer handler
  socket.on('sdp-offer', async ({ offer, from }) => {
    // Ensure PC exists
    let pc = peerConnections[from];
    if (!pc) {
      pc = createPeerConnection(from);
      peerConnections[from] = pc;
    }
    try {
      await pc.setRemoteDescription(new RTCSessionDescription(offer));
      const answer = await pc.createAnswer();
      await pc.setLocalDescription(answer);
      socket.emit('sdp-answer', { answer, to: from });
    } catch (err) {
      console.error('Handling offer error:', err);
    }
  });

  socket.on('sdp-answer', async ({ answer, from }) => {
    const pc = peerConnections[from];
    if (pc) {
      try { await pc.setRemoteDescription(new RTCSessionDescription(answer)); }
      catch (e) { console.error('setRemoteDescription answer error', e); }
    }
  });

  socket.on('ice-candidate', async ({ candidate, from }) => {
    const pc = peerConnections[from];
    if (pc) {
      try { await pc.addIceCandidate(new RTCIceCandidate(candidate)); }
      catch (err) { console.error('ICE candidate add error', err); }
    } else {
      // In rare cases, buffer candidate if you want (not implemented here)
      console.warn('Received ICE for unknown pc from', from);
    }
  });

  // ====== chat & typing ======
  socket.on('receive-message', (payload) => {
    // payload may be encrypted ciphertext if password used
    const plaintext = decryptForRoom(payload);
    addMessage('Partner', plaintext, false);
    if (!chatOpen) {
      unreadMessages++;
      updateMessageBadge();
    }
  });

  socket.on('typing', ({ isTyping }) => {
    const ind = document.getElementById('typingIndicator');
    ind.style.display = isTyping ? 'block' : 'none';
    if (isTyping) scrollToBottom();
  });

  document.getElementById('send-btn').addEventListener('click', sendMessage);
  document.getElementById('chat-input').addEventListener('keypress', (e) => { if (e.key === 'Enter') sendMessage(); });
  const chatInput = document.getElementById('chat-input');
  chatInput.addEventListener('input', () => {
    socket.emit('typing', { roomId, isTyping: true });
    clearTimeout(typingTimeout);
    typingTimeout = setTimeout(()=>{ socket.emit('typing', { roomId, isTyping: false }); }, 1000);
  });

  function sendMessage() {
    const raw = document.getElementById('chat-input').value.trim();
    if (!raw) return;
    const safe = raw.substring(0, 500);
    const cipher = encryptForRoom(safe);
    socket.emit('send-message', { roomId, message: cipher });
    addMessage('You', safe, true);
    document.getElementById('chat-input').value = '';
    scrollToBottom();
    socket.emit('typing', { roomId, isTyping: false });
  }

  // ====== reactions ======
  socket.on('receive-reaction', (reaction) => { showReaction(reaction); });
  document.getElementById('heartBtn').addEventListener('click', () => { socket.emit('send-reaction', { roomId, reaction: 'heart' }); showReaction('heart'); });
  document.getElementById('kissBtn').addEventListener('click', () => { socket.emit('send-reaction', { roomId, reaction: 'kiss' }); showReaction('kiss'); });

  function showReaction(type) {
    const overlay = document.getElementById('reactionOverlay');
    overlay.innerText = type === 'heart' ? 'ðŸ’“' : 'ðŸ’‹';
    overlay.style.display = 'flex';
    setTimeout(()=>{ overlay.style.display = 'none'; }, 1600);
  }

  // ====== controls (mic/cam/flip/end) ======
  document.getElementById('micToggle').addEventListener('click', () => {
    if (!localStream) return;
    const audioTracks = localStream.getAudioTracks();
    audioTracks.forEach(t => t.enabled = !t.enabled);
    micEnabled = audioTracks[0]?.enabled ?? false;
    document.getElementById('micToggle').style.backgroundColor = micEnabled ? 'rgba(255,255,255,0.2)' : 'rgba(255,0,0,0.5)';
  });

  document.getElementById('camToggle').addEventListener('click', () => {
    if (!localStream) return;
    const videoTracks = localStream.getVideoTracks();
    videoTracks.forEach(t => t.enabled = !t.enabled);
    camEnabled = videoTracks[0]?.enabled ?? false;
    document.getElementById('camToggle').style.backgroundColor = camEnabled ? 'rgba(255,255,255,0.2)' : 'rgba(255,0,0,0.5)';
    document.getElementById('localVideo').style.opacity = camEnabled ? '1' : '0.5';
  });

  document.getElementById('flipCam').addEventListener('click', async () => {
    const newFacing = currentFacing === 'user' ? 'environment' : 'user';
    try {
      // get only video from the camera we want
      const newStream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: newFacing } });
      const newVideoTrack = newStream.getVideoTracks()[0];
      if (!newVideoTrack) throw new Error('No video track from new stream');

      // Remove & stop existing video tracks from localStream and from senders
      const oldVideoTracks = localStream.getVideoTracks().slice(); // copy
      oldVideoTracks.forEach(track => {
        // remove from stream
        try { localStream.removeTrack(track); } catch (e) {}
        try { track.stop(); } catch (e) {}
      });

      // Add the new video track to localStream
      localStream.addTrack(newVideoTrack);

      // replace senders' video track
      Object.values(peerConnections).forEach(pc => {
        try {
          const sender = pc.getSenders().find(s => s.track && s.track.kind === 'video');
          if (sender) sender.replaceTrack(newVideoTrack);
        } catch (e) { console.warn('replaceTrack error', e); }
      });

      // Update UI
      document.getElementById('localVideo').srcObject = null;
      document.getElementById('localVideo').srcObject = localStream;
      currentFacing = newFacing;
      document.getElementById('localVideo').classList.toggle('mirrored', newFacing === 'user');

      // cleanup temporary stream (if any audio track exists there, stop it)
      newStream.getAudioTracks().forEach(t => t.stop());
    } catch (err) {
      console.error('Camera switch failed:', err);
      alert('Camera switch error â€” audio remains active.');
    }
  });

  document.getElementById('endCall').addEventListener('click', () => {
    if (confirm('End the call for both participants?')) {
      socket.emit('end-session', { roomId });
      if (localStream) localStream.getTracks().forEach(t => t.stop());
      Object.values(peerConnections).forEach(pc => pc.close());
      setTimeout(()=> window.location.href = '/goodbye.html', 300);
    }
  });

  socket.on('session-ended', () => {
    alert('Your partner has ended the session');
    if (localStream) localStream.getTracks().forEach(t => t.stop());
    Object.values(peerConnections).forEach(pc => pc.close());
    window.location.href = '/';
  });

  // ====== chat toggle & UI focus behaviors ======
  document.getElementById('chat-toggle').addEventListener('click', () => {
    chatOpen = !chatOpen;
    document.getElementById('chat-toggle').classList.toggle('active', chatOpen);
    document.getElementById('chat-container').style.display = chatOpen ? 'block' : 'none';
    document.getElementById('chat-input-container').style.display = chatOpen ? 'flex' : 'none';
    if (chatOpen) {
      unreadMessages = 0;
      updateMessageBadge();
      document.getElementById('chat-input').focus();
      scrollToBottom();
    }
  });

  // When input focused (mobile keyboard), shrink remote video so it doesn't hide
  chatInput.addEventListener('focus', () => {
    document.documentElement.style.setProperty('--keyboard-offset', '280px');
  });
  chatInput.addEventListener('blur', () => {
    document.documentElement.style.setProperty('--keyboard-offset', '0px');
  });

  // ====== initialization & join ======
  async function init() {
    updateConnectionStatus('Initializing media...');
    const ok = await initMedia();
    if (!ok) {
      if (retryCount < MAX_RETRIES) {
        retryCount++;
        setTimeout(init, 2000);
        return;
      } else {
        alert('Could not access camera/microphone. Please check permissions.');
        window.location.href = '/';
        return;
      }
    }

    // ask for password (used for room auth AND optional message encryption)
    password = prompt('Enter room password (used for access and optional chat encryption):') || '';
    if (!password) {
      alert('Password is required!');
      window.location.href = '/';
      return;
    }

    // Join room
    socket.emit('join-room', { roomId, password });
  }

  // Leave cleanup
  window.addEventListener('beforeunload', () => {
    if (socket.connected) {
      socket.emit('leave-room', { roomId }, () => {
        if (localStream) localStream.getTracks().forEach(t => t.stop());
        Object.values(peerConnections).forEach(pc => pc.close());
      });
    }
  });

  window.addEventListener('pagehide', () => {
    if (socket.connected) socket.emit('end-session', { roomId });
  });

  // Kick off
  init();
  </script>
</body>
</html>
