<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>LoveRoom üíñ</title>
  <script src="https://cdn.socket.io/4.0.1/socket.io.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
  <style>
    body { background-color: #000; margin: 0; padding: 0; overflow: hidden; }
    #remoteVideo {
      width: 100%;
      height: 100vh;
      object-fit: cover;
      position: absolute;
      top: 0;
      left: 0;
      z-index: 1;
    }
    #localVideo {
      width: 120px;
      height: 160px;
      object-fit: cover;
      border-radius: 8px;
      border: 2px solid white;
      position: absolute;
      bottom: 20px;
      right: 20px;
      z-index: 2;
    }
    #localVideo.mirrored { transform: scaleX(-1); }
    #controls {
      position: absolute;
      bottom: 80px;
      left: 0;
      right: 0;
      display: flex;
      justify-content: center;
      gap: 15px;
      z-index: 3;
    }
    .control-btn {
      width: 50px;
      height: 50px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      background-color: rgba(255, 255, 255, 0.2);
      backdrop-filter: blur(5px);
      color: white;
      font-size: 20px;
    }
    #chat-container {
      position: absolute;
      bottom: 180px;
      left: 20px;
      right: 20px;
      max-height: 200px;
      overflow-y: auto;
      z-index: 3;
      display: none;
      padding: 10px;
    }
    #messages {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .message-bubble {
      max-width: 80%;
      padding: 8px 12px;
      border-radius: 18px;
      color: white;
      word-wrap: break-word;
      backdrop-filter: blur(5px);
    }
    .my-message { 
      background-color: rgba(0, 0, 0, 0.3);
      margin-left: auto;
      border-bottom-right-radius: 4px;
    }
    .partner-message { 
      background-color: rgba(0, 0, 0, 0.3);
      margin-right: auto;
      border-bottom-left-radius: 4px;
    }
    #chat-input-container {
      position: absolute;
      bottom: 20px;
      left: 20px;
      right: 20px;
      display: flex;
      gap: 10px;
      z-index: 3;
      display: none;
    }
    #chat-input {
      flex-grow: 1;
      padding: 12px 20px;
      border-radius: 25px;
      border: none;
      background-color: rgba(255, 255, 255, 0.9);
      font-size: 16px;
    }
    #send-btn {
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background-color: #25D366;
      color: white;
      border: none;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-size: 20px;
    }
    #chat-toggle {
      position: absolute;
      bottom: 180px;
      right: 20px;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background-color: rgba(255, 255, 255, 0.2);
      backdrop-filter: blur(5px);
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      z-index: 3;
      color: white;
      font-size: 20px;
    }
    #reactionOverlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 100px;
      z-index: 4;
      animation: fadeOut 2s ease-in-out forwards;
      text-shadow: 0 0 20px rgba(255, 0, 0, 0.8);
      display: none;
    }
    @keyframes fadeOut {
      0% { opacity: 1; transform: scale(1); }
      100% { opacity: 0; transform: scale(2); }
    }
    #connectionStatus {
      position: absolute;
      top: 20px;
      left: 20px;
      padding: 5px 10px;
      border-radius: 20px;
      color: white;
      background-color: rgba(0, 0, 0, 0.5);
      z-index: 3;
      font-size: 14px;
    }
    #typingIndicator {
      color: white;
      font-style: italic;
      font-size: 12px;
      padding: 5px 10px;
      display: none;
      background-color: rgba(0, 0, 0, 0.3);
      border-radius: 10px;
      margin-top: 5px;
      width: fit-content;
    }
    /* Custom scrollbar for chat */
    #chat-container::-webkit-scrollbar {
      width: 6px;
    }
    #chat-container::-webkit-scrollbar-track {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 3px;
    }
    #chat-container::-webkit-scrollbar-thumb {
      background: rgba(255, 255, 255, 0.3);
      border-radius: 3px;
    }
  </style>
</head>
<body>
  <div id="connectionStatus">Connecting...</div>
  
  <video id="remoteVideo" autoplay playsinline></video>
  <video id="localVideo" autoplay muted playsinline class="mirrored"></video>

  <div id="controls">
    <div id="micToggle" class="control-btn">üé§</div>
    <div id="camToggle" class="control-btn">üì∑</div>
    <div id="flipCam" class="control-btn">üîÑ</div>
    <div id="endCall" class="control-btn bg-red-500">üìû</div>
    <div id="heartBtn" class="control-btn">üíì</div>
    <div id="kissBtn" class="control-btn">üíã</div>
  </div>

  <div id="chat-toggle">üí¨</div>

  <div id="chat-container">
    <div id="messages"></div>
    <div id="typingIndicator">Partner is typing...</div>
  </div>

  <div id="chat-input-container">
    <input id="chat-input" type="text" placeholder="Type a message..." />
    <button id="send-btn">‚û§</button>
  </div>

  <div id="reactionOverlay"></div>

  <script>
    // Connection state management
    let isCaller = false;
    let makingOffer = false;
    let ignoreOffer = false;
    let reconnectAttempts = 0;
    const maxReconnectAttempts = 3;
    let reconnectTimer = null;

    const roomId = window.location.pathname.split("/").pop();
    const socket = io({
      reconnectionAttempts: 5,
      reconnectionDelay: 1000,
      reconnectionDelayMax: 5000
    });
    const roomPassword = prompt("üîê Enter room password:");

    // Update connection status UI
    function updateConnectionStatus(status) {
      const statusEl = document.getElementById("connectionStatus");
      statusEl.textContent = status;
      statusEl.style.backgroundColor = 
        status === "Connected" ? "rgba(40, 167, 69, 0.8)" : 
        status === "Disconnected" ? "rgba(220, 53, 69, 0.8)" : "rgba(255, 193, 7, 0.8)";
    }

    // Attempt reconnection
    function attemptReconnect() {
      if (reconnectAttempts < maxReconnectAttempts) {
        reconnectAttempts++;
        updateConnectionStatus(`Reconnecting (${reconnectAttempts}/${maxReconnectAttempts})`);
        reconnectTimer = setTimeout(initializeConnection, 2000 * reconnectAttempts);
      } else {
        updateConnectionStatus("Disconnected");
        alert("Connection failed. Please refresh the page.");
      }
    }

    // Initialize connection
    function initializeConnection() {
      updateConnectionStatus("Connecting...");
      socket.emit("join-room", { roomId, password: roomPassword });
    }

    // Encryption setup
    const keyCache = new Map();
    const deriveKey = (password, salt) => CryptoJS.PBKDF2(password, salt, {
      keySize: 256/32, iterations: 10000, hasher: CryptoJS.algo.SHA256
    });
    const getDerivedKey = (password, saltHex) => {
      if (!keyCache.has(saltHex)) {
        const salt = CryptoJS.enc.Hex.parse(saltHex);
        keyCache.set(saltHex, deriveKey(password, salt));
      }
      return keyCache.get(saltHex);
    };

    // Reaction animation
    function showReaction(type) {
      const emoji = type === "heart" ? "üíì" : "üíã";
      const overlay = document.getElementById("reactionOverlay");
      overlay.innerText = emoji;
      overlay.style.display = "flex";
      setTimeout(() => {
        overlay.style.display = "none";
      }, 2000);
    }

    // WebRTC setup
    const localVideo = document.getElementById("localVideo");
    const remoteVideo = document.getElementById("remoteVideo");
    const peerConnection = new RTCPeerConnection({
      iceServers: [
        { urls: "stun:stun.l.google.com:19302" },
        // Add your TURN server here if available
      ],
      iceCandidatePoolSize: 10
    });

    let localStream;
    let micEnabled = true;
    let camEnabled = true;
    let currentFacing = "user";
    let chatOpen = false;

    // Initialize media and connection
    async function startMedia() {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: currentFacing }, 
          audio: true
        });
        
        localStream = stream;
        localVideo.srcObject = stream;
        stream.getTracks().forEach(track => peerConnection.addTrack(track, stream));
        updateConnectionStatus("Connected");
      } catch (err) {
        console.error("Media error:", err);
        updateConnectionStatus("Media Error");
        alert("Camera/mic access is required.");
      }
    }

    // WebRTC event handlers
    peerConnection.ontrack = (event) => {
      if (!remoteVideo.srcObject) {
        remoteVideo.srcObject = event.streams[0];
        updateConnectionStatus("Connected");
      }
    };

    peerConnection.onicecandidate = ({ candidate }) => {
      if (candidate) socket.emit("ice", { roomId, candidate });
    };

    peerConnection.oniceconnectionstatechange = () => {
      if (peerConnection.iceConnectionState === "disconnected") {
        updateConnectionStatus("Reconnecting...");
        attemptReconnect();
      }
    };

    peerConnection.onnegotiationneeded = async () => {
      try {
        makingOffer = true;
        await peerConnection.setLocalDescription();
        socket.emit("offer", { roomId, offer: peerConnection.localDescription });
      } catch (err) {
        console.error("Negotiation error:", err);
      } finally {
        makingOffer = false;
      }
    };

    // Socket.io event handlers
    socket.on("connect", () => {
      updateConnectionStatus("Connected");
      reconnectAttempts = 0;
      if (reconnectTimer) {
        clearTimeout(reconnectTimer);
        reconnectTimer = null;
      }
    });

    socket.on("disconnect", () => {
      updateConnectionStatus("Disconnected");
      attemptReconnect();
    });

    socket.on("join-room", () => {
      isCaller = true;
      startMedia();
    });

    socket.on("offer", async (offer) => {
      try {
        if (offer) {
          const offerCollision = (makingOffer || peerConnection.signalingState !== "stable");
          ignoreOffer = !isCaller && offerCollision;
          if (ignoreOffer) return;

          await peerConnection.setRemoteDescription(offer);
          if (offer.type === "offer") {
            await peerConnection.setLocalDescription();
            socket.emit("answer", { roomId, answer: peerConnection.localDescription });
          }
        }
      } catch (err) {
        console.error("Offer handling error:", err);
      }
    });

    socket.on("answer", async ({ answer }) => {
      if (!ignoreOffer) {
        try {
          await peerConnection.setRemoteDescription(answer);
        } catch (err) {
          console.error("Answer handling error:", err);
        }
      }
    });

    socket.on("ice", async ({ candidate }) => {
      try {
        await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
      } catch (err) {
        console.error("ICE error:", err);
      }
    });

    socket.on("reaction", ({ type }) => showReaction(type));
    socket.on("partner-left", () => {
      addMessage("System", "Your partner left the room.", false);
      remoteVideo.srcObject = null;
      updateConnectionStatus("Partner Disconnected");
    });

    // Chat functionality
    const chatInput = document.getElementById("chat-input");
    const messages = document.getElementById("messages");
    const typingIndicator = document.getElementById("typingIndicator");
    let typingTimeout;

    // Toggle chat visibility
    document.getElementById("chat-toggle").addEventListener("click", () => {
      chatOpen = !chatOpen;
      document.getElementById("chat-container").style.display = chatOpen ? "block" : "none";
      document.getElementById("chat-input-container").style.display = chatOpen ? "flex" : "none";
      if (chatOpen) {
        chatInput.focus();
        scrollToBottom();
      }
    });

    chatInput.addEventListener("input", () => {
      socket.emit("typing", roomId);
      clearTimeout(typingTimeout);
      typingTimeout = setTimeout(() => socket.emit("stop-typing", roomId), 1000);
    });

    socket.on("typing", () => {
      typingIndicator.style.display = "block";
      scrollToBottom();
    });
    socket.on("stop-typing", () => typingIndicator.style.display = "none");

    function sendMessage() {
      const msg = chatInput.value.trim();
      if (!msg) return;
      
      const salt = CryptoJS.lib.WordArray.random(16);
      const iv = CryptoJS.lib.WordArray.random(16);
      const saltHex = salt.toString(CryptoJS.enc.Hex);
      const ivHex = iv.toString(CryptoJS.enc.Hex);
      const key = getDerivedKey(roomPassword, saltHex);
      const encrypted = CryptoJS.AES.encrypt(msg, key, { iv }).toString();
      const payload = JSON.stringify({ salt: saltHex, iv: ivHex, data: encrypted });
      
      socket.emit("chat", { roomId, message: payload });
      addMessage("You", msg, true);
      chatInput.value = "";
      scrollToBottom();
    }

    // Send message on button click or Enter key
    document.getElementById("send-btn").addEventListener("click", sendMessage);
    chatInput.addEventListener("keypress", (e) => {
      if (e.key === "Enter") sendMessage();
    });

    function addMessage(sender, text, isMe) {
      const msg = document.createElement("div");
      msg.className = `message-bubble ${isMe ? "my-message" : "partner-message"}`;
      msg.innerHTML = `<strong>${sender}:</strong> ${text}`;
      messages.appendChild(msg);
      scrollToBottom();
    }

    function scrollToBottom() {
      const container = document.getElementById("chat-container");
      container.scrollTop = container.scrollHeight;
    }

    socket.on("chat", ({ message }) => {
      try {
        const payload = JSON.parse(message);
        const key = getDerivedKey(roomPassword, payload.salt);
        const iv = CryptoJS.enc.Hex.parse(payload.iv);
        const text = CryptoJS.AES.decrypt(payload.data, key, { iv }).toString(CryptoJS.enc.Utf8);
        if (text) {
          addMessage("Partner", text, false);
          if (!chatOpen) {
            // Show notification for new message when chat is closed
            const notification = document.createElement("div");
            notification.className = "message-bubble partner-message";
            notification.innerHTML = `<strong>Partner:</strong> ${text.substring(0, 20)}${text.length > 20 ? '...' : ''}`;
            notification.style.position = "absolute";
            notification.style.bottom = "250px";
            notification.style.right = "20px";
            notification.style.maxWidth = "200px";
            notification.style.animation = "fadeOut 3s forwards";
            document.body.appendChild(notification);
            setTimeout(() => notification.remove(), 3000);
          }
        }
        else throw new Error("Decryption failed");
      } catch (e) {
        console.error("Chat decryption error:", e);
        addMessage("System", "Failed to decrypt message", false);
      }
    });

    // UI Controls
    document.getElementById("micToggle").addEventListener("click", () => {
      micEnabled = !micEnabled;
      localStream?.getAudioTracks().forEach(track => track.enabled = micEnabled);
      document.getElementById("micToggle").innerText = micEnabled ? "üé§" : "üîá";
      document.getElementById("micToggle").style.backgroundColor = micEnabled ? 
        "rgba(255, 255, 255, 0.2)" : "rgba(255, 0, 0, 0.5)";
    });

    document.getElementById("camToggle").addEventListener("click", () => {
      camEnabled = !camEnabled;
      localStream?.getVideoTracks().forEach(track => track.enabled = camEnabled);
      document.getElementById("camToggle").innerText = camEnabled ? "üì∑" : "üö´";
      document.getElementById("camToggle").style.backgroundColor = camEnabled ? 
        "rgba(255, 255, 255, 0.2)" : "rgba(255, 0, 0, 0.5)";
      localVideo.style.opacity = camEnabled ? "1" : "0.5";
    });

    document.getElementById("flipCam").addEventListener("click", async () => {
      const videoTrack = localStream?.getVideoTracks()[0];
      const newFacing = currentFacing === "user" ? "environment" : "user";
      try {
        const newStream = await navigator.mediaDevices.getUserMedia({ 
          video: { facingMode: newFacing }, 
          audio: true 
        });
        const newVideoTrack = newStream.getVideoTracks()[0];
        const sender = peerConnection.getSenders().find(s => s.track?.kind === "video");
        await sender?.replaceTrack(newVideoTrack);
        videoTrack?.stop();
        localStream.removeTrack(videoTrack);
        localStream.addTrack(newVideoTrack);
        localVideo.srcObject = localStream;
        currentFacing = newFacing;
        localVideo.classList.toggle("mirrored", newFacing === "user");
        newStream.getAudioTracks().forEach(t => t.stop());
      } catch (err) {
        console.error("Camera switch error:", err);
        alert("Failed to switch camera");
      }
    });

    document.getElementById("endCall").addEventListener("click", () => {
      if (confirm("End the call?")) {
        window.close();
      }
    });

    // Reaction buttons
    document.getElementById("heartBtn").addEventListener("click", () => {
      socket.emit("reaction", { roomId, type: "heart" });
      showReaction("heart");
    });

    document.getElementById("kissBtn").addEventListener("click", () => {
      socket.emit("reaction", { roomId, type: "kiss" });
      showReaction("kiss");
    });

    // Cleanup on exit
    window.addEventListener("beforeunload", () => {
      localStream?.getTracks().forEach(track => track.stop());
      socket.emit("leave-room", roomId);
    });

    // Initialize everything
    initializeConnection();
    startMedia();
  </script>
</body>
</html>