<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>LoveRoom ðŸ’–</title>
  <script src="https://cdn.socket.io/4.0.1/socket.io.min.js"></script>
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
  <style>
    :root {
      --keyboard-offset: 0px;
    }
    body {
      background-color: #000;
      margin: 0;
      padding: 0;
      overflow: hidden;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }
    #remoteVideo {
      width: 100%;
      height: calc(100vh - var(--keyboard-offset));
      object-fit: cover;
      position: absolute;
      top: 0;
      left: 0;
      z-index: 1;
      transition: height 0.18s ease;
    }
    #localVideo {
      width: 120px;
      height: 160px;
      object-fit: cover;
      border-radius: 8px;
      border: 2px solid white;
      position: absolute;
      bottom: 20px;
      right: 20px;
      z-index: 2;
    }
    #localVideo.mirrored { transform: scaleX(-1); }
    #controls {
      position: absolute;
      bottom: 80px;
      left: 0;
      right: 0;
      display: flex;
      justify-content: center;
      gap: 15px;
      z-index: 3;
    }
    .control-btn {
      width: 50px;
      height: 50px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      background-color: rgba(255, 255, 255, 0.2);
      backdrop-filter: blur(5px);
      color: white;
      font-size: 20px;
      transition: background-color 0.3s;
      user-select: none;
    }
    #chat-container {
      position: absolute;
      bottom: 240px;
      left: 20px;
      right: 20px;
      max-height: 200px;
      overflow-y: auto;
      z-index: 3;
      display: none;
      padding: 10px;
      background-color: transparent;
      border-radius: 10px;
    }
    #messages { display: flex; flex-direction: column; gap: 8px; }
    .message-bubble { max-width: 80%; padding: 8px 12px; border-radius: 18px; color: white; word-wrap: break-word; }
    .my-message { background-color: rgba(0,0,0,0.55); margin-left: auto; border-bottom-right-radius: 4px; text-shadow: 0 0 5px black; }
    .partner-message { background-color: rgba(0,0,0,0.35); margin-right: auto; border-bottom-left-radius: 4px; text-shadow: 0 0 5px black; }
    #chat-input-container {
      position: absolute;
      bottom: 20px;
      left: 20px;
      right: 20px;
      display: none;
      gap: 10px;
      z-index: 3;
    }
    #chat-input {
      flex-grow: 1;
      padding: 12px 20px;
      border-radius: 25px;
      border: none;
      background-color: rgba(255, 255, 255, 0.95);
      font-size: 16px;
    }
    #send-btn {
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background-color: #25D366;
      color: white;
      border: none;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-size: 20px;
    }
    #chat-toggle {
      position: absolute;
      bottom: 180px;
      right: 20px;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background-color: rgba(255, 255, 255, 0.2);
      backdrop-filter: blur(5px);
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      z-index: 4;
      color: white;
      font-size: 20px;
      transition: all 0.3s;
      user-select: none;
    }
    #chat-toggle.active { background-color: rgba(255, 255, 255, 0.4); }
    #notification-badge {
      position: absolute;
      top: -5px;
      right: -5px;
      background-color: red;
      color: white;
      border-radius: 50%;
      width: 20px;
      height: 20px;
      display: none;
      align-items: center;
      justify-content: center;
      font-size: 12px;
    }
    #reactionOverlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      display: none;
      align-items: center;
      justify-content: center;
      font-size: 100px;
      z-index: 5;
      text-shadow: 0 0 20px rgba(255, 0, 0, 0.8);
      animation: fadeOut 2s ease-in-out forwards;
    }
    @keyframes fadeOut {
      0% { opacity: 1; transform: scale(1); }
      100% { opacity: 0; transform: scale(2); }
    }
    #connectionStatus {
      position: absolute;
      top: 20px;
      left: 20px;
      padding: 5px 10px;
      border-radius: 20px;
      color: white;
      background-color: rgba(0, 0, 0, 0.5);
      z-index: 3;
      font-size: 14px;
    }
    #typingIndicator {
      color: white;
      font-style: italic;
      font-size: 12px;
      padding: 5px 10px;
      display: none;
      background-color: rgba(0, 0, 0, 0.3);
      border-radius: 10px;
      margin-top: 5px;
      width: fit-content;
    }
    #roomFullOverlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.8);
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 10;
      color: white;
      font-size: 24px;
      text-align: center;
      padding: 20px;
    }
    #roomFullOverlay button {
      margin-top: 20px;
      padding: 10px 20px;
      background-color: #25D366;
      border: none;
      border-radius: 5px;
      color: white;
      font-size: 16px;
      cursor: pointer;
    }

    /* Chat scrollbar */
    #chat-container::-webkit-scrollbar {
      width: 6px;
    }
    #chat-container::-webkit-scrollbar-track {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 3px;
    }
    #chat-container::-webkit-scrollbar-thumb {
      background: rgba(255, 255, 255, 0.3);
      border-radius: 3px;
    }
  </style>
</head>
<body>
  <div id="connectionStatus">Connecting...</div>

  <div id="roomFullOverlay">
    <h2>This room is already full!</h2>
    <p>Only 2 people can join a LoveRoom at a time.</p>
    <button onclick="window.location.href='/'">Go Back</button>
  </div>

  <video id="remoteVideo" autoplay playsinline></video>
  <video id="localVideo" autoplay muted playsinline class="mirrored"></video>

  <div id="controls">
    <div id="micToggle" class="control-btn">ðŸŽ¤</div>
    <div id="camToggle" class="control-btn">ðŸ“·</div>
    <div id="flipCam" class="control-btn">ðŸ”„</div>
    <div id="endCall" class="control-btn bg-red-500">ðŸ“ž</div>
    <div id="heartBtn" class="control-btn">ðŸ’“</div>
    <div id="kissBtn" class="control-btn">ðŸ’‹</div>
  </div>

  <div id="chat-toggle">
    ðŸ’¬
    <div id="notification-badge"></div>
  </div>

  <div id="chat-container">
    <div id="messages"></div>
    <div id="typingIndicator">Partner is typing...</div>
  </div>

  <div id="chat-input-container">
    <input id="chat-input" type="text" placeholder="Type a message..." autocomplete="off" />
    <button id="send-btn">âž¤</button>
  </div>

  <div id="reactionOverlay"></div>

  <script>
    // ====== Basic variables ======
    const socket = io({ autoConnect: true, reconnectionAttempts: 5 });

    let peerConnections = {};
    let localStream = null;

    let currentFacing = "user";
    let micEnabled = true;
    let camEnabled = true;
    let chatOpen = false;
    let typingTimeout = null;
    let unreadMessages = 0;
    let roomPassword = "";

    const roomId = window.location.pathname.split('/').pop() || 'default';

    // DOM elements
    const localVideo = document.getElementById('localVideo');
    const remoteVideo = document.getElementById('remoteVideo');
    const connectionStatusEl = document.getElementById('connectionStatus');
    const chatContainer = document.getElementById('chat-container');
    const messagesEl = document.getElementById('messages');
    const typingIndicator = document.getElementById('typingIndicator');
    const chatInput = document.getElementById('chat-input');
    const chatInputContainer = document.getElementById('chat-input-container');
    const chatToggle = document.getElementById('chat-toggle');
    const notificationBadge = document.getElementById('notification-badge');
    const reactionOverlay = document.getElementById('reactionOverlay');
    const roomFullOverlay = document.getElementById('roomFullOverlay');

    // ====== Helpers ======
    function updateConnectionStatus(text) {
      connectionStatusEl.textContent = text;
      connectionStatusEl.style.backgroundColor =
        text.includes('Connected') ? 'rgba(40, 167, 69, 0.8)' :
        text.includes('Disconnected') ? 'rgba(220, 53, 69, 0.8)' :
        'rgba(255, 193, 7, 0.8)';
    }

    function sanitize(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    function addMessage(from, text, isMe) {
      const msg = document.createElement('div');
      msg.className = `message-bubble ${isMe ? 'my-message' : 'partner-message'}`;
      msg.innerHTML = `<strong>${from}:</strong> ${sanitize(text)}`;
      messagesEl.appendChild(msg);
      scrollMessagesToBottom();
    }

    function scrollMessagesToBottom() {
      const last = messagesEl.lastElementChild;
      if (last) {
        try {
          last.scrollIntoView({ behavior: 'smooth', block: 'end' });
        } catch (e) {
          chatContainer.scrollTop = chatContainer.scrollHeight;
        }
      }
    }

    function updateMessageBadge() {
      if (unreadMessages > 0) {
        notificationBadge.style.display = 'flex';
        notificationBadge.textContent = unreadMessages > 9 ? '9+' : unreadMessages;
      } else {
        notificationBadge.style.display = 'none';
      }
    }

    // ====== WebRTC: create peer connection ======
    function createPeerConnection(userId) {
      const pc = new RTCPeerConnection({
        iceServers: [
          { urls: 'stun:stun.l.google.com:19302' },
          { urls: 'stun:stun1.l.google.com:19302' }
          // Add your TURN server here for real internet usage
          // { urls: 'turn:your.turn.server:3478', username: 'user', credential: 'pass' }
        ]
      });

      pc._remoteCandidates = [];

      if (localStream) {
        localStream.getTracks().forEach(track => {
          try {
            pc.addTrack(track, localStream);
          } catch (e) {
            console.warn('addTrack error:', e);
          }
        });
      }

      pc.onicecandidate = (event) => {
        if (event.candidate) {
          socket.emit('ice-candidate', {
            candidate: event.candidate,
            to: userId
          });
        }
      };

      pc.ontrack = (event) => {
        // Just use first stream
        remoteVideo.srcObject = event.streams[0];
        updateConnectionStatus('Connected to partner');
      };

      pc.onconnectionstatechange = () => {
        console.log('Peer connection state:', pc.connectionState);
        if (pc.connectionState === 'connected') {
          updateConnectionStatus('Connected');
        } else if (pc.connectionState === 'disconnected') {
          updateConnectionStatus('Disconnected');
        } else if (pc.connectionState === 'failed') {
          updateConnectionStatus('Connection failed (retrying ICE)');
          try { pc.restartIce(); } catch(e) { console.warn('restartIce failed', e); }
        }
      };

      pc._flushRemoteCandidates = async () => {
        if (!pc.remoteDescription || pc.remoteDescription.type === null) return;
        const pending = pc._remoteCandidates;
        pc._remoteCandidates = [];
        for (const c of pending) {
          try {
            await pc.addIceCandidate(new RTCIceCandidate(c));
          } catch (err) {
            console.error('Late addIceCandidate error:', err);
          }
        }
      };

      return pc;
    }

    async function initiateCall(userId, pc) {
      try {
        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);
        socket.emit('sdp-offer', {
          offer: pc.localDescription,
          to: userId
        });
      } catch (err) {
        console.error('createOffer error:', err);
      }
    }

    // ====== Socket events ======
    socket.on('connect', () => {
      updateConnectionStatus('Connected to server');
      console.log('Socket connected:', socket.id);
    });

    socket.on('disconnect', (reason) => {
      updateConnectionStatus('Disconnected from server');
      console.log('Socket disconnected:', reason);
    });

    socket.on('existing-users', ({ users }) => {
      // This client is the "new" one; call existing peers
      users.forEach(userId => {
        if (!peerConnections[userId]) {
          const pc = createPeerConnection(userId);
          peerConnections[userId] = pc;
          initiateCall(userId, pc);
        }
      });
    });

    socket.on('user-connected', ({ userId }) => {
      // Another user joined; create PC so we can receive their offer
      if (!peerConnections[userId]) {
        const pc = createPeerConnection(userId);
        peerConnections[userId] = pc;
      }
    });

    socket.on('user-disconnected', ({ userId }) => {
      const pc = peerConnections[userId];
      if (pc) {
        try { pc.close(); } catch (e) {}
        delete peerConnections[userId];
      }
      remoteVideo.srcObject = null;
      updateConnectionStatus('Partner disconnected');
    });

    socket.on('room-full', () => {
      roomFullOverlay.style.display = 'flex';
      // Stop local media
      if (localStream) {
        localStream.getTracks().forEach(t => t.stop());
      }
      Object.values(peerConnections).forEach(pc => pc.close());
      peerConnections = {};
    });

    socket.on('invalid-password', () => {
      alert('Incorrect password!');
      window.location.href = '/';
    });

    // Signaling
    socket.on('sdp-offer', async ({ offer, from }) => {
      let pc = peerConnections[from];
      if (!pc) {
        pc = createPeerConnection(from);
        peerConnections[from] = pc;
      }
      try {
        await pc.setRemoteDescription(new RTCSessionDescription(offer));
        await pc._flushRemoteCandidates();
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        socket.emit('sdp-answer', {
          answer: pc.localDescription,
          to: from
        });
      } catch (err) {
        console.error('Error handling offer:', err);
      }
    });

    socket.on('sdp-answer', async ({ answer, from }) => {
      const pc = peerConnections[from];
      if (!pc) return;
      try {
        await pc.setRemoteDescription(new RTCSessionDescription(answer));
        await pc._flushRemoteCandidates();
      } catch (err) {
        console.error('Error handling answer:', err);
      }
    });

    socket.on('ice-candidate', async ({ candidate, from }) => {
      const pc = peerConnections[from];
      if (!pc) {
        console.warn('ICE for unknown peer', from);
        return;
      }
      if (!pc.remoteDescription || pc.remoteDescription.type === null) {
        pc._remoteCandidates.push(candidate);
      } else {
        try {
          await pc.addIceCandidate(new RTCIceCandidate(candidate));
        } catch (err) {
          console.error('addIceCandidate error:', err);
        }
      }
    });

    // Chat
    socket.on('receive-message', (message) => {
      addMessage('Partner', message, false);
      if (!chatOpen) {
        unreadMessages++;
        updateMessageBadge();
      }
    });

    socket.on('typing', ({ isTyping }) => {
      typingIndicator.style.display = isTyping ? 'block' : 'none';
      if (isTyping) scrollMessagesToBottom();
    });

    // Reactions
    socket.on('receive-reaction', (reaction) => {
      const emoji = reaction === 'kiss' ? 'ðŸ’‹' : 'ðŸ’“';
      reactionOverlay.textContent = emoji;
      reactionOverlay.style.display = 'flex';
      setTimeout(() => {
        reactionOverlay.style.display = 'none';
      }, 1600);
    });

    socket.on('session-ended', () => {
      alert('Your partner has ended the session.');
      if (localStream) {
        localStream.getTracks().forEach(t => t.stop());
      }
      Object.values(peerConnections).forEach(pc => pc.close());
      peerConnections = {};
      window.location.href = '/';
    });

    // ====== Chat input logic ======
    document.getElementById('send-btn').addEventListener('click', sendMessage);
    chatInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') sendMessage();
    });

    chatInput.addEventListener('input', () => {
      socket.emit('typing', { roomId, isTyping: true });
      clearTimeout(typingTimeout);
      typingTimeout = setTimeout(() => {
        socket.emit('typing', { roomId, isTyping: false });
      }, 1000);
    });

    function sendMessage() {
      const raw = chatInput.value.trim();
      if (!raw) return;
      const msg = raw.slice(0, 500);
      socket.emit('send-message', { roomId, message: msg });
      addMessage('You', msg, true);
      chatInput.value = '';
      scrollMessagesToBottom();
      socket.emit('typing', { roomId, isTyping: false });
    }

    // Chat toggle
    chatToggle.addEventListener('click', () => {
      chatOpen = !chatOpen;
      chatToggle.classList.toggle('active', chatOpen);
      chatContainer.style.display = chatOpen ? 'block' : 'none';
      chatInputContainer.style.display = chatOpen ? 'flex' : 'none';
      if (chatOpen) {
        unreadMessages = 0;
        updateMessageBadge();
        chatInput.focus();
        scrollMessagesToBottom();
      }
    });

    // Keyboard / mobile: shrink video when typing
    chatInput.addEventListener('focus', () => {
      document.documentElement.style.setProperty('--keyboard-offset', '260px');
    });
    chatInput.addEventListener('blur', () => {
      document.documentElement.style.setProperty('--keyboard-offset', '0px');
    });

    // ====== Controls (mic / cam / flip / end) ======
    document.getElementById('micToggle').addEventListener('click', () => {
      if (!localStream) return;
      const audioTracks = localStream.getAudioTracks();
      audioTracks.forEach(t => t.enabled = !t.enabled);
      micEnabled = audioTracks[0] ? audioTracks[0].enabled : false;
      document.getElementById('micToggle').style.backgroundColor =
        micEnabled ? 'rgba(255,255,255,0.2)' : 'rgba(255,0,0,0.5)';
    });

    document.getElementById('camToggle').addEventListener('click', () => {
      if (!localStream) return;
      const videoTracks = localStream.getVideoTracks();
      videoTracks.forEach(t => t.enabled = !t.enabled);
      camEnabled = videoTracks[0] ? videoTracks[0].enabled : false;
      document.getElementById('camToggle').style.backgroundColor =
        camEnabled ? 'rgba(255,255,255,0.2)' : 'rgba(255,0,0,0.5)';
      localVideo.style.opacity = camEnabled ? '1' : '0.5';
    });

    document.getElementById('flipCam').addEventListener('click', async () => {
      const newFacing = currentFacing === 'user' ? 'environment' : 'user';
      try {
        const newStream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: newFacing }
        });

        const newVideoTrack = newStream.getVideoTracks()[0];
        if (!newVideoTrack) throw new Error('No video track in new stream');

        // Remove old video tracks
        localStream.getVideoTracks().forEach(track => {
          try { track.stop(); } catch (e) {}
          try { localStream.removeTrack(track); } catch (e) {}
        });

        // Add new track
        localStream.addTrack(newVideoTrack);

        // Replace track in all peer connections
        Object.values(peerConnections).forEach(pc => {
          const sender = pc.getSenders().find(s => s.track && s.track.kind === 'video');
          if (sender) {
            sender.replaceTrack(newVideoTrack).catch(e => console.warn('replaceTrack error', e));
          }
        });

        // Update local video element
        localVideo.srcObject = null;
        localVideo.srcObject = localStream;
        currentFacing = newFacing;
        localVideo.classList.toggle('mirrored', newFacing === 'user');

        // Stop temp stream audio tracks
        newStream.getAudioTracks().forEach(t => t.stop());
      } catch (err) {
        console.error('Camera switch failed:', err);
        alert('Unable to switch camera.');
      }
    });

    document.getElementById('heartBtn').addEventListener('click', () => {
      socket.emit('send-reaction', { roomId, reaction: 'heart' });
      showLocalReaction('ðŸ’“');
    });

    document.getElementById('kissBtn').addEventListener('click', () => {
      socket.emit('send-reaction', { roomId, reaction: 'kiss' });
      showLocalReaction('ðŸ’‹');
    });

    function showLocalReaction(emoji) {
      reactionOverlay.textContent = emoji;
      reactionOverlay.style.display = 'flex';
      setTimeout(() => { reactionOverlay.style.display = 'none'; }, 1600);
    }

    document.getElementById('endCall').addEventListener('click', () => {
      if (confirm('End the call for both participants?')) {
        socket.emit('end-session', { roomId });
        if (localStream) {
          localStream.getTracks().forEach(t => t.stop());
        }
        Object.values(peerConnections).forEach(pc => pc.close());
        peerConnections = {};
        setTimeout(() => {
          window.location.href = '/';
        }, 300);
      }
    });

    // ====== Init: get media + join room ======
    async function init() {
      updateConnectionStatus('Requesting camera & microphone...');
      try {
        localStream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: currentFacing },
          audio: true
        });
        localVideo.srcObject = localStream;
      } catch (err) {
        console.error('getUserMedia error:', err);
        alert('Could not access camera/microphone. Please check permissions.');
        window.location.href = '/';
        return;
      }

      const pwd = prompt('Enter room password:');
      if (!pwd) {
        alert('Password is required!');
        window.location.href = '/';
        return;
      }
      roomPassword = pwd;

      socket.emit('join-room', { roomId, password: roomPassword });
      updateConnectionStatus('Joining room...');
    }

    // Cleanup on unload
    window.addEventListener('beforeunload', () => {
      if (socket.connected) {
        socket.emit('leave-room', { roomId });
      }
      if (localStream) {
        localStream.getTracks().forEach(t => t.stop());
      }
      Object.values(peerConnections).forEach(pc => pc.close());
      peerConnections = {};
    });

    window.addEventListener('pagehide', () => {
      if (socket.connected) {
        socket.emit('end-session', { roomId });
      }
    });

    // Start it
    init();
  </script>
</body>
</html>
